##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################

apiVersion: batch/v1
kind: Job
metadata:
  name: installchaincode-{{ $.Values.peer.name }}-{{ $.Values.chaincode.name }}-{{ $.Values.chaincode.version }}
  namespace: {{ $.Values.metadata.namespace }}
  labels:
    app: installchaincode-{{ $.Values.peer.name }}-{{ $.Values.chaincode.name }}-{{ $.Values.chaincode.version }}
    app.kubernetes.io/name: installchaincode-{{ $.Values.chaincode.name }}{{ $.Values.chaincode.version }}
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    {{- include "labels.custom" . | nindent 2 }}
spec:
  backoffLimit: 6
  template:
    metadata:
      labels:
        app: installchaincode-{{ $.Values.peer.name }}-{{ $.Values.chaincode.name }}-{{ $.Values.chaincode.version }}
        app.kubernetes.io/name: installchaincode-{{ $.Values.chaincode.name }}{{ $.Values.chaincode.version }}
        helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
        app.kubernetes.io/managed-by: {{ .Release.Service }}
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      restartPolicy: OnFailure
      serviceAccountName: {{ $.Values.vault.serviceaccountname }}
      {{- if .Values.vault.imagesecretname }}
      imagePullSecrets:
        - name: {{ $.Values.vault.imagesecretname }}
      {{- end }}
      volumes:
      {{ if .Values.vault.tls  }}
      - name: vaultca
        secret:
          secretName: {{ $.Values.vault.tls }}
          items:
          - key: ca.crt.pem
            path: ca-certificates.crt
      {{ end  }}
      - name: certificates
        emptyDir:
          medium: Memory
      - name: scripts-volume
        configMap:
          name: bevel-vault-script
      - name: package-manager
        configMap:
          name: package-manager
      initContainers:
      - name: certificates-init
        image: {{ $.Values.metadata.images.alpineutils }}
        imagePullPolicy: IfNotPresent
        env:
        - name: VAULT_ADDR
          value: {{ $.Values.vault.address }}
        - name: KUBERNETES_AUTH_PATH
          value: {{ $.Values.vault.authpath }}
        - name: VAULT_APP_ROLE
          value: {{ $.Values.vault.role }}
        - name: VAULT_PEER_SECRET_PREFIX
          value: "{{ $.Values.vault.adminsecretprefix }}"
        - name: VAULT_ORDERER_SECRET_PREFIX
          value: "{{ $.Values.vault.orderersecretprefix }}"
        - name: MOUNT_PATH
          value: /secret
        - name: NETWORK_VERSION
          value: "2.2.2"
        - name: VAULT_TYPE
          value: "{{ $.Values.vault.type }}"
        command: ["sh", "-c"]
        args:
        - |-
          #!/usr/bin/env sh
          source /scripts/bevel-vault.sh

          # Calling a function to retrieve the vault token.
          vaultBevelFunc "init"

          echo "Getting Orderer TLS certificates from Vault."
          vaultBevelFunc "readJson" "${VAULT_ORDERER_SECRET_PREFIX}/tls"

          TLS_CA_CERT=$(echo ${VAULT_SECRET} | jq -r '.["ca.crt"]')
          OUTPUT_PATH="${MOUNT_PATH}/orderer/tls"
          mkdir -p ${OUTPUT_PATH}
          echo "${TLS_CA_CERT}" >> ${OUTPUT_PATH}/ca.crt

          echo "Getting MSP certificates from Vault."
          vaultBevelFunc "readJson" "${VAULT_PEER_SECRET_PREFIX}/msp"

          ADMINCERT=$(echo ${VAULT_SECRET} | jq -r '.["admincerts"]')
          CACERTS=$(echo ${VAULT_SECRET} | jq -r '.["cacerts"]')
          KEYSTORE=$(echo ${VAULT_SECRET} | jq -r '.["keystore"]')
          SIGNCERTS=$(echo ${VAULT_SECRET} | jq -r '.["signcerts"]')
          TLSCACERTS=$(echo ${VAULT_SECRET} | jq -r '.["tlscacerts"]')

          OUTPUT_PATH="${MOUNT_PATH}/admin/msp"
          mkdir -p ${OUTPUT_PATH}/admincerts
          mkdir -p ${OUTPUT_PATH}/cacerts
          mkdir -p ${OUTPUT_PATH}/keystore
          mkdir -p ${OUTPUT_PATH}/signcerts
          mkdir -p ${OUTPUT_PATH}/tlscacerts

          echo "${ADMINCERT}" >> ${OUTPUT_PATH}/admincerts/admin.crt
          echo "${CACERTS}" >> ${OUTPUT_PATH}/cacerts/ca.crt
          echo "${KEYSTORE}" >> ${OUTPUT_PATH}/keystore/server.key
          echo "${SIGNCERTS}" >> ${OUTPUT_PATH}/signcerts/server.crt
          echo "${TLSCACERTS}" >> ${OUTPUT_PATH}/tlscacerts/tlsca.crt

          # GIT user creds
          vault_secret_key={{ $.Values.vault.secretgitprivatekey }}

          # Calling a function to retrieve secrets from Vault only if they exist.
          vaultBevelFunc "readJson" "${vault_secret_key}"
          
          VALUE_OF_SECRET=$(echo ${VAULT_SECRET} | jq -r ".[\"git_password\"]")         
          echo "${VALUE_OF_SECRET}" >> ${MOUNT_PATH}/user_cred
        volumeMounts:
        {{ if .Values.vault.tls  }}
        - name: vaultca
          mountPath: "/etc/ssl/certs/"
          readOnly: true
        {{ end }}
        - name: certificates
          mountPath: /secret
        - name: scripts-volume
          mountPath: /scripts/bevel-vault.sh
          subPath: bevel-vault.sh
      containers:
      - name: installchaincode
        image: {{ $.Values.metadata.images.fabrictools }}
        imagePullPolicy: IfNotPresent
        stdin: true
        tty: true
        command: ["sh", "-c"]
        args:
        - |-
          #!/bin/bash sh 

          . /scripts/package-manager.sh
           
          # Define the packages to install
          packages_to_install="curl openssh"
          install_packages "$packages_to_install"

          #creating go directory
          GOPATH="/root/go"
          mkdir -p $GOPATH

           #remove go version 1.14
           rm -rf /usr/local/go
          

          # Create symbolic link for libc.musl-x86_64.so.1
          mkdir /lib64 && ln -s /lib/libc.musl-x86_64.so.1 /lib64/ld-linux-x86-64.so.2

          #download fabric
          mkdir -p $GOPATH/src/github.com/hyperledger
          cd $GOPATH/src/github.com/hyperledger
          git clone -b release-1.2 https://github.com/hyperledger/fabric.git

          # Create directory
          mkdir -p /root/.ssh/     
          ssh-keyscan {{ $.Values.chaincode.repository.hostname }} > /root/.ssh/known_hosts
          git_password=$(cat /opt/gopath/src/github.com/hyperledger/fabric/crypto/user_cred)
          cd /tmp && git clone https://{{ $.Values.chaincode.repository.git_username }}:$git_password@{{ $.Values.chaincode.repository.url }} -b {{ $.Values.chaincode.repository.branch }} chaincode > git.log 2>&1

          ## Check if the repository was cloned correctly
          if [ $? -ne 0 ]; then
              cat git.log
              exit 1
          fi
         
         
          # Download and extract Go 1.17
          if wget -c https://dl.google.com/go/go1.17.linux-amd64.tar.gz -O - |  tar -xz -C /root ; then
              echo "Go 1.17 downloaded and extracted successfully."
              # Set up environment variables
              export PATH=$PATH:$GOPATH/bin

  
          else
            echo "Failed to download or extract Go 1.17. Exiting..."
            exit 1
          fi

          if [ "${CC_RUNTIME_LANGUAGE}" = "golang" ]; then
             ## Copying desired chaincode to a location relative to $GOPATH/src
             mkdir -p $GOPATH/src/github.com/chaincode
             cp -R /tmp/chaincode/{{ $.Values.chaincode.repository.path }}/* $GOPATH/src/github.com/chaincode/

             cd $GOPATH/src/github.com/chaincode/
             go mod init github.com/chaincode

             # Replace import paths in go.mod file
             go install github.com/hyperledger/fabric@v2.2.2
             go install github.com/kardianos/govendor
             go install github.com/hyperledger/fabric-chaincode-go@v0.0.0-20190823162523-04390e015b85
             go install github.com/hyperledger/fabric-protos-go@v0.0.0-20190821214336-621b908d5022
             go install github.com/hyperledger/fabric/common/util@v1.4
             go install github.com/benbjohnson/clock@v1.3.5
             go install github.com/hyperledger/fabric-protos-go@v0.3.0
             go install github.com/hyperledger/fabric/protos/msp
             go install github.com/golang/protobuf@v1.3.1
             go install github.com/golang/protobuf/proto
             go install github.com/franela/goblin@v0.0.2
             go install golang.org/x/net@v0.17.0
             go install golang.org/x/sys@v0.13.0
             go install golang.org/x/text@v0.13.0
             go install google.golang.org/genproto@v0.0.0-20230410155749-daa745c078e1
             go install google.golang.org/grpc@v1.56.3
             go install google.golang.org/protobuf@v1.33.0

            # Check if the vendor directory exists
            if [ ! -d vendor ]; then

              # Tidy up module dependencies
              go mod tidy -e

              # Vendor dependencies
              GO111MODULE=on go mod vendor
              go mod vendor
              
              cat go.mod
            fi

          fi

          CC_SRC_PATH="github.com/chaincode/${CHAINCODE_NAME}/${CHAINCODE_MAINDIR}"
           echo "Installing Chaincode for ${NETWORK_VERSION}"
            if [ $PEER_NAME = "peer0" ];then
              ## packaging chaincode
              echo "Packaging chaincode for the first peer"
              peer lifecycle chaincode package ${CHAINCODE_NAME}.tar.gz --path ${CC_SRC_PATH} --lang ${CC_RUNTIME_LANGUAGE} --label ${CHAINCODE_NAME}_${CHAINCODE_VERSION}
            else
              export CORE_PEER_ADDRESS=${PEER0_ADDRESS}
              echo "Extracting package id"
              peer lifecycle chaincode queryinstalled > log.txt
              PACKAGE_ID=$(cat log.txt | grep "${CHAINCODE_NAME}_${CHAINCODE_VERSION}" | sed -n "/${CC_NAME}_${CC_VERSION}/{s/^Package ID: //; s/, Label:.*$//; p;}")
              echo "Package Id Extracted ${PACKAGE_ID}"
              peer lifecycle chaincode getinstalledpackage --package-id ${PACKAGE_ID}
              export CORE_PEER_ADDRESS=${PEER_ADDRESS}
              export CHAINCODE_NAME=${PACKAGE_ID}
              echo "installing ${CHAINCODE_NAME} on ${CORE_PEER_ADDRESS}"
            fi
            ## Installing Chaincode
            peer lifecycle chaincode install ${CHAINCODE_NAME}.tar.gz
            echo "Chaincode installed for Fabric v.2.X"
            ## Check if chaincode got installed 
            INSTALLED=$(peer lifecycle chaincode queryinstalled -O json | jq '.installed_chaincodes?' | \
              jq --arg CCLABEL "${CHAINCODE_NAME}_${CHAINCODE_VERSION}" '.[]? | select(.label==$CCLABEL)')
            if ! [ -n "${INSTALLED}" ]
            then
              echo "Error while installing chaincode, exiting.."
              exit 1
            fi
          fi

          #query installed
          echo "peer query installed"
          peer lifecycle chaincode queryinstalled

          #query installed
          echo "peer query installed"
          peer lifecycle chaincode queryinstalled

        env:
        - name: PEER_NAME
          value: {{ $.Values.peer.name }}
        - name: PEER0_ADDRESS
          value: peer0.{{ $.Values.metadata.namespace }}:7051
        - name: PEER_ADDRESS
          value: {{ $.Values.peer.address }}
        - name: CORE_VM_ENDPOINT
          value: unix:///host/var/run/docker.sock
        - name: FABRIC_LOGGING_SPEC
          value: {{ $.Values.peer.loglevel }}
        - name: CORE_PEER_ID
          value: {{ $.Values.peer.name }}.{{ $.Values.metadata.namespace }}
        - name: CORE_PEER_ADDRESS
          value: {{ $.Values.peer.address }}
        - name: CORE_PEER_LOCALMSPID
          value: {{ $.Values.peer.localmspid }}
        - name: CORE_PEER_TLS_ENABLED
          value: "{{ $.Values.peer.tlsstatus }}"
        - name: CORE_PEER_TLS_ROOTCERT_FILE
          value: /opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp/tlscacerts/tlsca.crt
        - name: ORDERER_CA
          value: /opt/gopath/src/github.com/hyperledger/fabric/crypto/orderer/tls/ca.crt
        - name: ORDERER_URL
          value: {{ $.Values.orderer.address }}
        - name: CORE_PEER_MSPCONFIGPATH
          value: /opt/gopath/src/github.com/hyperledger/fabric/crypto/admin/msp
        - name: CHAINCODE_NAME
          value: "{{ $.Values.chaincode.name }}"
        - name: CHAINCODE_MAINDIR
          value: "{{ $.Values.chaincode.maindirectory }}"
        - name: CHAINCODE_VERSION
          value: "{{ $.Values.chaincode.version }}"
        - name: CORE_CHAINCODE_BUILDER
          value: "{{ $.Values.chaincode.builder }}"
        - name: NETWORK_VERSION
          value: "{{ $.Values.metadata.network.version }}"
        - name: CC_RUNTIME_LANGUAGE
          value: "{{ $.Values.chaincode.lang }}"
        volumeMounts:
        - name: certificates
          mountPath: /opt/gopath/src/github.com/hyperledger/fabric/crypto
          readOnly: true
        - name: package-manager
          mountPath: /scripts/package-manager.sh
          subPath: package-manager.sh